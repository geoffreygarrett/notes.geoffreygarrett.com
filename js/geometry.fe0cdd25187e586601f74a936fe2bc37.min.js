import*as THREE from"https://cdn.skypack.dev/three@0.124.0";import{OrbitControls}from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/controls/OrbitControls";import{GLTFLoader}from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/loaders/GLTFLoader";import{FBXLoader}from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/loaders/FBXLoader";import{EffectComposer}from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/postprocessing/EffectComposer";import Stats from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/libs/stats.module";import{RenderPass}from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/postprocessing/RenderPass.js";import{ShaderPass}from"https://cdn.skypack.dev/three@0.124.0/examples/jsm/postprocessing/ShaderPass.js";import gsap from"https://cdn.skypack.dev/gsap@3.6.0";const calcAspect=e=>e.clientWidth/e.clientHeight,getNormalizedMousePos=e=>({x:e.clientX/window.innerWidth*2-1,y:-(e.clientY/window.innerHeight)*2+1}),getBaryCoord=e=>{const n=e.attributes.position.array.length,s=n/3,t=[];for(let e=0;e<s;e++)t.push(0,0,1,0,1,0,1,0,0);const o=new Float32Array(t);e.setAttribute("aCenter",new THREE.BufferAttribute(o,3))},gridIcosahedronTextureUrl=`https://i.loli.net/2021/03/09/1Cglerjx3yLauOo.jpg`,gridIcosahedronShapeVertexShader=`
#define GLSLIFY 1
//
// GLSL textureless classic 3D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

// https://tympanus.net/codrops/2019/10/29/real-time-multiside-refraction-in-three-steps/
vec4 getWorldPosition(mat4 modelMat,vec3 pos){
    vec4 worldPosition=modelMat*vec4(pos,1.);
    return worldPosition;
}

// https://tympanus.net/codrops/2019/10/29/real-time-multiside-refraction-in-three-steps/
vec3 getEyeVector(mat4 modelMat,vec3 pos,vec3 camPos){
    vec4 worldPosition=getWorldPosition(modelMat,pos);
    vec3 eyeVector=normalize(worldPosition.xyz-camPos);
    return eyeVector;
}

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vEyeVector;

uniform float uNoiseDensity;

void main(){
    // 噪声扭曲顶点
    vec3 noise=pow(cnoise(normal),3.)*normal*uNoiseDensity;
    vec3 newPos=position+noise;
    
    vec4 modelPosition=modelMatrix*vec4(newPos,1.);
    vec4 viewPosition=viewMatrix*modelPosition;
    vec4 projectedPosition=projectionMatrix*viewPosition;
    gl_Position=projectedPosition;
    
    vUv=uv;
    
    // 获取N和I
    vNormal=normalize(normalMatrix*normal);
    vEyeVector=getEyeVector(modelMatrix,position,cameraPosition);
}
`,gridIcosahedronShapeFragmentShader=`
#define GLSLIFY 1
// https://community.khronos.org/t/getting-the-normal-with-dfdx-and-dfdy/70177
vec3 computeNormal(vec3 normal){
    vec3 X=dFdx(normal);
    vec3 Y=dFdy(normal);
    vec3 cNormal=normalize(cross(X,Y));
    return cNormal;
}

// http://glslsandbox.com/e#47182.0
vec2 hash22(vec2 p){
    p=fract(p*vec2(5.3983,5.4427));
    p+=dot(p.yx,p.xy+vec2(21.5351,14.3137));
    return fract(vec2(p.x*p.y*95.4337,p.x*p.y*97.597));
}

// https://www.shadertoy.com/view/4scSW4
float fresnel(float bias,float scale,float power,vec3 I,vec3 N)
{
    return bias+scale*pow(1.+dot(I,N),power);
}

float invert(float n){
    return 1.-n;
}

vec3 invert(vec3 n){
    return 1.-n;
}

uniform float uTime;
uniform vec2 uMouse;
uniform vec2 uResolution;
uniform sampler2D uTexture;
uniform float uRefractionStrength;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vEyeVector;

void main(){
    vec2 newUv=vUv;
    
    // 平滑着色
    vec3 cNormal=computeNormal(vNormal);
    
    // 漫反射
    float diffuse=dot(cNormal,vec3(1.));
    
    // 折射随机度
    vec2 rand=hash22(vec2(floor(diffuse*10.)));
    vec2 strength=vec2(sign((rand.x-.5))+(rand.x-.5)*.6,sign((rand.y-.5))+(rand.y-.5)*.6);
    newUv=strength*gl_FragCoord.xy/vec2(1000.);
    
    // 折射
    vec3 refraction=.3*refract(vEyeVector,cNormal,1./3.);
    newUv+=refraction.xy;
    
    // 材质贴图
    vec4 texture=texture2D(uTexture,newUv);
    vec4 color=texture;
    
    // 菲涅尔反射
    float F=fresnel(0.,1.,2.,vEyeVector,cNormal);
    color*=(1.-F);
    
    gl_FragColor=color;
}
`,gridIcosahedronEdgeVertexShader=`
#define GLSLIFY 1
//
// GLSL textureless classic 3D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

varying vec2 vUv;
varying vec3 vCenter;

attribute vec3 aCenter;

uniform float uNoiseDensity;

void main(){
    // 噪声扭曲顶点
    vec3 noise=pow(cnoise(normal),3.)*normal*uNoiseDensity;
    vec3 newPos=position+noise;
    
    vec4 modelPosition=modelMatrix*vec4(newPos,1.);
    vec4 viewPosition=viewMatrix*modelPosition;
    vec4 projectedPosition=projectionMatrix*viewPosition;
    gl_Position=projectedPosition;
    
    vUv=uv;
    
    vCenter=aCenter;
}
`,gridIcosahedronEdgeFragmentShader=`
uniform float uTime;
uniform vec2 uMouse;
uniform vec2 uResolution;
uniform float uWidth;

varying vec2 vUv;
varying vec3 vCenter;

// https://threejs.org/examples/?q=wire#webgl_materials_wireframe
float edgeFactorTri(){
    vec3 d=fwidth(vCenter);
    vec3 a3=smoothstep(d*(uWidth-.5),d*(uWidth+.5),vCenter);
    return min(min(a3.x,a3.y),a3.z);
}

float invert(float n){
    return 1.-n;
}

void main(){
    float line=invert(edgeFactorTri());
    if(line<.1){
        discard;
    }
    vec4 color=vec4(vec3(line),1.);
    gl_FragColor=color;
}
`,gridIcosahedronPostprocessingVertexShader=`
varying vec2 vUv;

void main(){
    vec4 modelPosition=modelMatrix*vec4(position,1.);
    vec4 viewPosition=viewMatrix*modelPosition;
    vec4 projectedPosition=projectionMatrix*viewPosition;
    gl_Position=projectedPosition;
    
    vUv=uv;
}
`,gridIcosahedronPostprocessingFragmentShader=`
#define GLSLIFY 1
// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
float hash(vec2 p){return fract(1e4*sin(17.*p.x+p.y*.1)*(.1+abs(sin(p.y*13.+p.x))));}

vec3 blackAndWhite(vec3 color){
    return vec3((color.r+color.g+color.b)/5.);
}

vec4 RGBShift(sampler2D t,vec2 rUv,vec2 gUv,vec2 bUv,float isBlackWhite){
    vec4 color1=texture2D(t,rUv);
    vec4 color2=texture2D(t,gUv);
    vec4 color3=texture2D(t,bUv);
    if(isBlackWhite==1.){
        color1.rgb=blackAndWhite(color1.rgb);
        color2.rgb=blackAndWhite(color2.rgb);
        color3.rgb=blackAndWhite(color3.rgb);
    }
    vec4 color=vec4(color1.r,color2.g,color3.b,color2.a);
    return color;
}

uniform float uTime;
uniform vec2 uMouse;
uniform vec2 uResolution;
uniform sampler2D tDiffuse;
uniform float uRGBShift;

varying vec2 vUv;

void main(){
    vec2 newUv=vUv;
    
    // RGB扭曲
    vec2 rUv=vUv+vec2(.01)*uRGBShift;
    vec2 gUv=vUv+vec2(0.);
    vec2 bUv=vUv+vec2(.01)*uRGBShift*-1.;
    vec4 color=RGBShift(tDiffuse,rUv,gUv,bUv,1.);
    
    // 噪声背景
    float noise=hash(newUv+uTime)*.15;
    color.rgb+=vec3(noise);
    
    gl_FragColor=color;
}
`;class Base{constructor(e,t=!1){this.debug=t,this.container=document.querySelector(e),this.perspectiveCameraParams={fov:75,near:.1,far:100},this.orthographicCameraParams={zoom:2,near:-100,far:1e3},this.cameraPosition=new THREE.Vector3(0,3,10),this.lookAtPosition=new THREE.Vector3(0,0,0),this.rendererParams={outputEncoding:THREE.LinearEncoding,config:{alpha:!0,antialias:!0}},this.mousePos=new THREE.Vector2(0,0)}init(){this.createScene(),this.createPerspectiveCamera(),this.createRenderer(),this.createMesh({}),this.createLight(),this.createOrbitControls(),this.addListeners(),this.setLoop()}createScene(){const e=new THREE.Scene;if(this.debug){e.add(new THREE.AxesHelper);const t=Stats();this.container.appendChild(t.dom),this.stats=t}this.scene=e}createPerspectiveCamera(){const{perspectiveCameraParams:t,cameraPosition:r,lookAtPosition:n}=this,{fov:s,near:o,far:i}=t,a=calcAspect(this.container),e=new THREE.PerspectiveCamera(s,a,o,i);e.position.copy(r),e.lookAt(n),this.camera=e}createOrthographicCamera(){const{orthographicCameraParams:t,cameraPosition:n,lookAtPosition:s}=this,{left:l,right:o,top:i,bottom:a,near:r,far:c}=t,e=new THREE.OrthographicCamera(l,o,i,a,r,c);e.position.copy(n),e.lookAt(s),this.camera=e}updateOrthographicCameraParams(){const{container:n}=this,{zoom:e,near:s,far:o}=this.orthographicCameraParams,t=calcAspect(n);this.orthographicCameraParams={left:-e*t,right:e*t,top:e,bottom:-e,near:s,far:o,zoom:e}}createRenderer(s=!1){var t;const{rendererParams:o}=this,{outputEncoding:i,config:n}=o,e=s?new THREE.WebGL1Renderer(n):new THREE.WebGLRenderer(n);e.setSize(this.container.clientWidth,this.container.clientHeight),e.outputEncoding=i,this.resizeRendererToDisplaySize(),(t=this.container)===null||t===void 0?void 0:t.appendChild(e.domElement),this.renderer=e,this.renderer.setClearColor(0,0)}enableShadow(){this.renderer.shadowMap.enabled=!0}resizeRendererToDisplaySize(){const{renderer:e}=this;if(!e)return;const t=e.domElement,n=window.devicePixelRatio,{clientWidth:a,clientHeight:r}=t,s=a*n|0,o=r*n|0,i=t.width!==s||t.height!==o;return i&&e.setSize(s,o,!1),i}createMesh(t,n=this.scene){const{geometry:s=new THREE.BoxGeometry(1,1,1),material:o=new THREE.MeshStandardMaterial({color:new THREE.Color("#d9dfc8")}),position:i=new THREE.Vector3(0,0,0)}=t,e=new THREE.Mesh(s,o);return e.position.copy(i),n.add(e),e}createLight(){const e=new THREE.DirectionalLight(new THREE.Color("#ffffff"),.5);e.position.set(0,50,0),this.scene.add(e);const t=new THREE.AmbientLight(new THREE.Color("#ffffff"),.4);this.scene.add(t)}createOrbitControls(){const e=new OrbitControls(this.camera,this.renderer.domElement),{lookAtPosition:t}=this;e.target.copy(t),e.update(),this.controls=e}addListeners(){this.onResize()}onResize(){window.addEventListener("resize",e=>{if(this.camera instanceof THREE.PerspectiveCamera){const t=calcAspect(this.container),e=this.camera;e.aspect=t,e.updateProjectionMatrix()}else if(this.camera instanceof THREE.OrthographicCamera){this.updateOrthographicCameraParams();const e=this.camera,{left:t,right:n,top:s,bottom:o,near:i,far:a}=this.orthographicCameraParams;e.left=t,e.right=n,e.top=s,e.bottom=o,e.near=i,e.far=a,e.updateProjectionMatrix()}this.renderer.setSize(this.container.clientWidth,this.container.clientHeight)})}update(){console.log("animation")}setLoop(){this.renderer.setAnimationLoop(()=>{this.resizeRendererToDisplaySize(),this.update(),this.controls&&this.controls.update(),this.stats&&this.stats.update(),this.composer?this.composer.render():this.renderer.render(this.scene,this.camera)})}createText(e="",t,n=new THREE.MeshStandardMaterial({color:"#ffffff"})){const s=new THREE.TextGeometry(e,t),o=new THREE.Mesh(s,n);return o}createAudioSource(){const e=new THREE.AudioListener;this.camera.add(e);const t=new THREE.Audio(e);this.sound=t}loadAudio(e){const t=new THREE.AudioLoader;return new Promise(n=>{t.load(e,e=>{this.sound.setBuffer(e),n(e)})})}loadModel(e){const t=new GLTFLoader;return new Promise((n,s)=>{t.load(e,e=>{const t=e.scene;n(t)},void 0,e=>{console.log(e),s()})})}loadFBXModel(e){const t=new FBXLoader;return new Promise((n,s)=>{t.load(e,e=>{n(e)},void 0,e=>{console.log(e),s()})})}loadFont(e){const t=new THREE.FontLoader;return new Promise(n=>{t.load(e,e=>{n(e)})})}createRaycaster(){this.raycaster=new THREE.Raycaster,this.trackMousePos()}trackMousePos(){window.addEventListener("mousemove",e=>{this.setMousePos(e)}),window.addEventListener("mouseout",()=>{this.clearMousePos()}),window.addEventListener("mouseleave",()=>{this.clearMousePos()}),window.addEventListener("touchstart",e=>{this.setMousePos(e.touches[0])},{passive:!1}),window.addEventListener("touchmove",e=>{this.setMousePos(e.touches[0])}),window.addEventListener("touchend",()=>{this.clearMousePos()})}setMousePos(e){const{x:t,y:n}=getNormalizedMousePos(e);this.mousePos.x=t,this.mousePos.y=n}clearMousePos(){this.mousePos.x=-1e5,this.mousePos.y=-1e5}getInterSects(){this.raycaster.setFromCamera(this.mousePos,this.camera);const e=this.raycaster.intersectObjects(this.scene.children,!0);return e}onChooseIntersect(t){const n=this.getInterSects(),e=n[0];if(!e||!e.face)return null;const{object:s}=e;return t===s?e:null}}class GridIcosahedron extends Base{constructor(e,t){super(e,t),this.clock=new THREE.Clock,this.cameraPosition=new THREE.Vector3(0,0,2),this.params={uNoiseDensity:0},this.mouseSpeed=0}init(){this.createScene(),this.createPerspectiveCamera(),this.createRenderer(),this.createGridIcosahedronShapeMaterial(),this.createGridIcosahedronEdgeMaterial(),this.createIcoShape(),this.createIcoEdge(),this.createPostprocessingEffect(),this.createLight(),this.trackMouseSpeed(),this.createOrbitControls(),this.addListeners(),this.setLoop()}createGridIcosahedronShapeMaterial(){const t=new THREE.TextureLoader,e=t.load(gridIcosahedronTextureUrl);e.wrapS=e.wrapT=THREE.MirroredRepeatWrapping;const n=new THREE.ShaderMaterial({vertexShader:gridIcosahedronShapeVertexShader,fragmentShader:gridIcosahedronShapeFragmentShader,side:THREE.DoubleSide,uniforms:{uTime:{value:0},uMouse:{value:new THREE.Vector2(0,0)},uResolution:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},uTexture:{value:e},uRefractionStrength:{value:.2},uNoiseDensity:{value:this.params.uNoiseDensity}}});this.gridIcosahedronShapeMaterial=n}createGridIcosahedronEdgeMaterial(){const e=new THREE.ShaderMaterial({vertexShader:gridIcosahedronEdgeVertexShader,fragmentShader:gridIcosahedronEdgeFragmentShader,side:THREE.DoubleSide,uniforms:{uTime:{value:0},uMouse:{value:new THREE.Vector2(0,0)},uResolution:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},uWidth:{value:2},uNoiseDensity:{value:this.params.uNoiseDensity}}});this.gridIcosahedronEdgeMaterial=e}createIcoShape(){const e=new THREE.IcosahedronBufferGeometry(1,1),t=this.gridIcosahedronShapeMaterial;this.createMesh({geometry:e,material:t})}createIcoEdge(){const e=new THREE.IcosahedronBufferGeometry(1.001,1);getBaryCoord(e);const t=this.gridIcosahedronEdgeMaterial;this.createMesh({geometry:e,material:t})}getBaryCoord(e){const n=e.attributes.position.array.length,s=n/3,t=[];for(let e=0;e<s;e++)t.push(0,0,1,0,1,0,1,0,0);const o=new Float32Array(t);e.setAttribute("aCenter",new THREE.BufferAttribute(o,3))}createPostprocessingEffect(){const e=new EffectComposer(this.renderer),n=new RenderPass(this.scene,this.camera);e.addPass(n);const t=new ShaderPass({vertexShader:gridIcosahedronPostprocessingVertexShader,fragmentShader:gridIcosahedronPostprocessingFragmentShader,uniforms:{tDiffuse:{value:null},uTime:{value:0},uRGBShift:{value:.3}}});t.renderToScreen=!0,e.addPass(t),this.composer=e,this.customPass=t}update(){const e=this.clock.getElapsedTime(),n=this.mousePos,t=this.mouseSpeed*5;this.gridIcosahedronShapeMaterial&&(this.gridIcosahedronShapeMaterial.uniforms.uTime.value=e,this.gridIcosahedronShapeMaterial.uniforms.uMouse.value=n,this.scene.rotation.x=e/15,this.scene.rotation.y=e/15,gsap.to(this.gridIcosahedronShapeMaterial.uniforms.uNoiseDensity,{value:t,duration:2}),gsap.to(this.gridIcosahedronEdgeMaterial.uniforms.uNoiseDensity,{value:t,duration:2})),this.customPass&&(this.customPass.uniforms.uTime.value=e,gsap.to(this.customPass.uniforms.uRGBShift,{value:t/10,duration:2}))}trackMouseSpeed(){let e=-1,t=-1,n=0;window.addEventListener("mousemove",s=>{const o=s.pageX,i=s.pageY;e>-1&&(n=Math.max(Math.abs(o-e),Math.abs(i-t)),this.mouseSpeed=n/100),e=o,t=i}),document.addEventListener("mouseleave",()=>{this.mouseSpeed=0})}}const start=()=>{const e=new GridIcosahedron(".grid-icosahedron",!1);e.init()};start()